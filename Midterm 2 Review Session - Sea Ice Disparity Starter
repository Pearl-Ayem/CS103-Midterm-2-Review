{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [],
   "source": [
    "from cs103 import*\n",
    "from typing import  NamedTuple, List\n",
    "import csv\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Step 1a\n",
    "File: Sub-Region sea Ice Trends\n",
    "\n",
    "The file contains information about Sub-region sea ice area in Northern Canadian Waters from 1968 to 2015. It includes data for \n",
    "- Foxe Basin\n",
    "- Kane Basin\n",
    "- Baffin Bay\n",
    "- Beaufort Sea\n",
    "- Canadian Arctic Achipelago\n",
    "- Hudson Bay\n",
    "- Hudson Strait\n",
    "- Davis Strait\n",
    "- North Labrador Sea\n",
    "\n",
    "All sea ice area is in units thousands of square kilometres"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Step 1b\n",
    "\n",
    "What a program operating on this information might produce:\n",
    "\n",
    "Region with highest sea ice area in a given year.\n",
    "\n",
    "Region with higest average sea ice.\n",
    "\n",
    "Difference in sea ice for a particular reagion.\n",
    "\n",
    "The year with the highest average sea ice.\n",
    "\n",
    "Change in sea ice area compared to the previous year."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### In our example we will choose to use this data to find the year with the highest sea ice, year with the lowest sea ice for the Hudson Strait region"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Step 1c\n",
    "Here's an  example that shows the kind of output we expect from this program:\n",
    "```python\n",
    "expect(main('Sub-region sea ice trends.csv'),\n",
    "       Sea_Ice_Disparity(1975,2015,-49))\n",
    "```\n",
    "\n",
    "##### Note: In this example the output is a compound called Sea_Ice_Disparity. The data definition for this compound is provided in the starter file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {},
   "outputs": [],
   "source": [
    "# I will need the year and sea ice area from Hudson Strait from each row (year, Hudson Strait sea ice area (thousands of square kilometres))\n",
    "\n",
    "Sea_Ice_Disparity = NamedTuple ('Sea_Ice_Disparity',[('year_highest', int), #in range [1968,2015]\n",
    "                                                    ('year_lowest', int), #year with lowest sea ice area in range [1968,2015]\n",
    "                                                    ('difference', int)]) \n",
    "# interp. year with highest sea ice area(year_highest), year with lowest sea ice area (year_lowest) \n",
    "#      and the difference in sea ice area between the highest and lowest years. \n",
    "\n",
    "SID1= Sea_Ice_Disparity(1985,2014, -15) #from test file 1\n",
    "SID2= Sea_Ice_Disparity(1969,2002, -10)  #from test file 2\n",
    "SID3= Sea_Ice_Disparity(1972,2010, -47) # from original file\n",
    "\n",
    "# template based on compound (3 fields) and the reference rule (twice)\n",
    "def fn_for_sea_ice_disparity(sid: Sea_Ice_Disparity) -> ...:\n",
    "    return ...(sd.year_highest,\n",
    "               sd.year_lowest,\n",
    "               sd.difference)\n",
    "\n",
    "\n",
    "Ice_Coverage = NamedTuple('Ice_Coverage', [('year', int),# in range [1968,2015]\n",
    "                                           ('ice_area', int)])\n",
    "# interp. Ice Coverage data with year a the sea ice area is in units thousands of square kilometres. \n",
    "\n",
    "#from test file 1\n",
    "IC1_1= Ice_Coverage(1968,21)\n",
    "IC1_2= Ice_Coverage(1985,27)\n",
    "IC1_3= Ice_Coverage(1986,21)\n",
    "IC1_4= Ice_Coverage(1987,26)\n",
    "IC1_5= Ice_Coverage(1988,23)\n",
    "IC1_6= Ice_Coverage(1989,20)\n",
    "IC1_7= Ice_Coverage(2014,12)\n",
    "IC1_8= Ice_Coverage(2015,18)\n",
    "\n",
    "#from test file 2\n",
    "IC2_1= Ice_Coverage(1968,21)\n",
    "IC2_2= Ice_Coverage(1969,25)\n",
    "IC2_3= Ice_Coverage(2002,15)\n",
    "IC2_4= Ice_Coverage(2015,18)\n",
    "\n",
    "# template based on compound (3 fields) and the reference rule (twice)\n",
    "def fn_for_ice_coverage(ic: Ice_Coverage) -> ...:\n",
    "    return ...(ic.year,\n",
    "               ic.ice_area)\n",
    "\n",
    "\n",
    "# List[Ice_Coverage]\n",
    "# interp. a list of information about sea ice coverage in Hudson Strait\n",
    "L0 = []\n",
    "L1 = [IC1_1,IC1_2,IC1_3,IC1_4,IC1_5,IC1_6,IC1_7,IC1_8]  # test file 1\n",
    "L2 = [IC2_1,IC2_2,IC2_3,IC2_4]  # test file 2\n",
    "\n",
    "# Template based on arbitrary-sized and the reference rule\n",
    "def fn_for_lonr(loic: List[Ice_Coverage]) -> ...:\n",
    "    # description of the acc\n",
    "    acc = ...    # type: ...\n",
    "    for ic in loic:\n",
    "        acc = ...(fn_for_ice_coverage(ic), acc)\n",
    "    return ...(acc)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2b and 2c -> design read and the rest of the program"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[92m17 of 17 tests passed\u001b[0m\n"
     ]
    }
   ],
   "source": [
    "@typecheck\n",
    "def main(fn: str) -> Optional[Sea_Ice_Disparity]:\n",
    "    \"\"\"\n",
    "    Reads the file from given filename and returns the Sea_Ice_Disparity of the given data\n",
    "    \"\"\"\n",
    "    # template as a function composition\n",
    "    return analyze(read(fn))    \n",
    "    \n",
    "@typecheck\n",
    "def read(fn: str) -> List[Ice_Coverage]:\n",
    "    \"\"\"    \n",
    "    Reads the file from given filename and returns a list of the\n",
    "    Ice_Coverage\n",
    "    \"\"\"\n",
    "    #return []   #stub\n",
    "    #template from HtDAP\n",
    "    \n",
    "    # loic contains the result so far\n",
    "    loic = []   # type: List[Ice_Coverage]\n",
    "    with open(fn, encoding = \"ISO-8859-1\") as csvfile:\n",
    "        reader = csv.reader(csvfile, delimiter=',')\n",
    "        \n",
    "        next(reader) # skip first 3 lines\n",
    "        next(reader)\n",
    "        next(reader)\n",
    "        \n",
    "        for row in reader:\n",
    "            if is_valid(row[0],row[7]):\n",
    "                year = parse_int(row[0])\n",
    "                ice_coverage = parse_int(row[7])\n",
    "                ic = Ice_Coverage(year,ice_coverage)  \n",
    "                loic.append(ic)\n",
    "    return loic\n",
    "\n",
    "@typecheck\n",
    "def analyze(loic: List[Ice_Coverage]) -> Optional[Sea_Ice_Disparity]:\n",
    "    \"\"\"\n",
    "    return the Sea_Ice_Disparity using the given list of Ice Coverage data\n",
    "    \"\"\"\n",
    "    \n",
    "    if loic ==[]:\n",
    "        return None\n",
    "    \n",
    "    highest = loic[0]\n",
    "    lowest = loic[0]\n",
    "    \n",
    "    for ic in loic:\n",
    "        highest = higher_ice_coverage(ic,highest)\n",
    "        lowest = lower_ice_coverage(ic,lowest)\n",
    "        \n",
    "        \n",
    "    difference = difference_in_coverage(lowest,highest)    \n",
    "    return Sea_Ice_Disparity(highest.year,lowest.year,difference)\n",
    "        \n",
    "@typecheck\n",
    "def is_valid(s1: str,s2: str) -> bool:\n",
    "    \"\"\"\n",
    "    return True if none of the above given strings are empty, False otherwise\n",
    "    \"\"\"\n",
    "    # return False # body of the stub\n",
    "    # return ... (s1,s2,s3) template based on atomic non-distinct\n",
    "    \n",
    "    return s1.strip() != \"\" and s2.strip() != \"\"\n",
    "    \n",
    "\n",
    "@typecheck\n",
    "def higher_ice_coverage(ic1: Ice_Coverage, ic2: Ice_Coverage) -> Ice_Coverage:\n",
    "    \"\"\"\n",
    "    return the Ice_Coverage data with the highest ice coverage\n",
    "    \"\"\"\n",
    "    # return ic1 # body of the stub\n",
    "    # template based on Ice_Coverage\n",
    "    if ic1.ice_area > ic2.ice_area:\n",
    "        return ic1\n",
    "    else:\n",
    "        return ic2\n",
    "    \n",
    "    \n",
    "def lower_ice_coverage(ic1: Ice_Coverage, ic2: Ice_Coverage) -> Ice_Coverage:\n",
    "    \"\"\"\n",
    "    return the Ice_Coverage data with the lowest ice coverage\n",
    "    \"\"\"\n",
    "    # return ic1 # body of the stub\n",
    "    # template based on Ice_Coverage\n",
    "    if ic1.ice_area < ic2.ice_area:\n",
    "        return ic1\n",
    "    else:\n",
    "        return ic2\n",
    "\n",
    "    \n",
    "def difference_in_coverage(ic1: Ice_Coverage, ic2: Ice_Coverage) -> int:\n",
    "    \"\"\"\n",
    "    return the difference in the ice coverage between 2 years\n",
    "    \"\"\"\n",
    "    \n",
    "    #return 0 #stub\n",
    "    #template based on Ice Coverage\n",
    "    \n",
    "    return ic1.ice_area - ic2.ice_area\n",
    "\n",
    "\n",
    "start_testing()\n",
    "#tests for main\n",
    "expect(main(\"Sub-region sea ice area trends.csv\"), SID3)\n",
    "expect(main(\"Sub-region sea ice area trends test 1.csv\"), SID1)\n",
    "expect(main(\"Sub-region sea ice area trends test 2.csv\"), SID2)\n",
    "\n",
    "#tests for analyze\n",
    "expect(analyze(L0), None)\n",
    "expect(analyze(L1), SID1)\n",
    "expect(analyze(L2), SID2)\n",
    "\n",
    "#tests for is_valid\n",
    "expect(is_valid(\"hello\",\"hi\"), True)\n",
    "expect(is_valid(\"     \",\"hi\"), False)\n",
    "\n",
    "#tests for higher_ice_coverage\n",
    "expect(higher_ice_coverage(IC1_1,IC1_3), IC1_3)\n",
    "expect(higher_ice_coverage(IC1_3,IC1_2), IC1_2)\n",
    "expect(higher_ice_coverage(IC1_2,IC1_3), IC1_2)\n",
    "\n",
    "#tests for lower_ice_coverage\n",
    "expect(lower_ice_coverage(IC1_1,IC1_3), IC1_3)\n",
    "expect(lower_ice_coverage(IC1_3,IC1_2), IC1_3)\n",
    "expect(lower_ice_coverage(IC1_2,IC1_3), IC1_3)\n",
    "\n",
    "#tests for difference_in_coverage\n",
    "expect(difference_in_coverage(IC1_1,IC1_3), 0)\n",
    "expect(difference_in_coverage(IC1_3,IC1_2), -6)\n",
    "expect(difference_in_coverage(IC1_2,IC1_3), 6)\n",
    "\n",
    "summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
